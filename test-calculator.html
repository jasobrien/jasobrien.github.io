<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Property Calculator Test Suite</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
    background: #f5f5f5;
  }
  h1 { color: #333; border-bottom: 3px solid #1c7ed6; padding-bottom: 10px; }
  h2 { color: #1c7ed6; margin-top: 30px; }
  .test-suite { background: white; padding: 20px; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
  .test-case { 
    padding: 12px; 
    margin: 8px 0; 
    border-left: 4px solid #ccc; 
    background: #f9f9f9;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .test-case.pass { border-color: #10b981; background: #d1fae5; }
  .test-case.fail { border-color: #ef4444; background: #fee2e2; }
  .test-name { font-weight: 600; flex: 1; }
  .test-result { margin-left: 20px; }
  .pass .test-result::before { content: '‚úÖ PASS'; color: #065f46; font-weight: bold; }
  .fail .test-result::before { content: '‚ùå FAIL'; color: #991b1b; font-weight: bold; }
  .test-details { font-size: 12px; color: #666; margin-top: 4px; }
  .fail .test-details { color: #991b1b; }
  .summary { 
    background: #1c7ed6; 
    color: white; 
    padding: 20px; 
    border-radius: 8px; 
    margin: 20px 0;
    font-size: 18px;
  }
  .summary.fail { background: #ef4444; }
  .run-btn {
    background: #1c7ed6;
    color: white;
    padding: 12px 24px;
    border: none;
    border-radius: 6px;
    font-size: 16px;
    cursor: pointer;
    margin: 10px 5px;
  }
  .run-btn:hover { background: #1565c0; }
  iframe { display: none; }
</style>
</head>
<body>
  <h1>üß™ Property Investment Calculator Test Suite</h1>
  <p>Comprehensive automated testing for calculation accuracy and UI behavior.</p>
  
  <div>
    <button class="run-btn" onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
    <button class="run-btn" onclick="runCalculationTests()">üî¢ Run Calculation Tests Only</button>
    <button class="run-btn" onclick="runUITests()">üñ•Ô∏è Run UI Tests Only</button>
  </div>

  <div id="summary"></div>
  <div id="results"></div>

  <!-- Hidden iframe to load the calculator -->
  <iframe id="calculator" src="InvestorCalculator.html"></iframe>

<script>
// Test Framework
const tests = [];
let totalTests = 0;
let passedTests = 0;
let failedTests = 0;

function test(name, category, fn) {
  tests.push({ name, category, fn });
}

function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}

function assertApprox(actual, expected, tolerance, message) {
  const diff = Math.abs(actual - expected);
  if (diff > tolerance) {
    throw new Error(message || `Expected ${expected} ¬± ${tolerance}, got ${actual} (diff: ${diff})`);
  }
}

// ============================================================================
// CALCULATION TESTS - Pure function tests
// ============================================================================

// NSW Stamp Duty Calculation Tests
test('NSW Stamp Duty: $16,000 property', 'calculation', () => {
  const duty = calcNSWDuty(16000);
  assert(duty === 200, `Expected 200, got ${duty}`);
});

test('NSW Stamp Duty: $35,000 property', 'calculation', () => {
  const duty = calcNSWDuty(35000);
  assert(duty === 485, `Expected 485, got ${duty}`);
});

test('NSW Stamp Duty: $500,000 property', 'calculation', () => {
  const duty = calcNSWDuty(500000);
  assertApprox(duty, 17990, 10, `Expected ~17990, got ${duty}`);
});

test('NSW Stamp Duty: $1,000,000 property', 'calculation', () => {
  const duty = calcNSWDuty(1000000);
  assertApprox(duty, 39780, 10, `Expected ~39780, got ${duty}`);
});

test('NSW Stamp Duty: $2,000,000 property', 'calculation', () => {
  const duty = calcNSWDuty(2000000);
  assertApprox(duty, 93045, 10, `Expected ~93045, got ${duty}`);
});

// Loan Repayment Calculation Tests
test('Loan repayment: $400k @ 6% for 30 years', 'calculation', () => {
  const principal = 400000;
  const rate = 6 / 100 / 12;
  const n = 30 * 12;
  const payment = principal * (rate / (1 - Math.pow(1 + rate, -n)));
  assertApprox(payment, 2398, 5, `Expected ~$2,398/month, got $${Math.round(payment)}`);
});

test('Loan repayment: $500k @ 7% for 25 years', 'calculation', () => {
  const principal = 500000;
  const rate = 7 / 100 / 12;
  const n = 25 * 12;
  const payment = principal * (rate / (1 - Math.pow(1 + rate, -n)));
  assertApprox(payment, 3535, 5, `Expected ~$3,535/month, got $${Math.round(payment)}`);
});

test('Loan repayment: Zero interest rate edge case', 'calculation', () => {
  const principal = 300000;
  const n = 30 * 12;
  const payment = principal / n;
  assert(payment === 833.33, `Expected 833.33, got ${payment.toFixed(2)}`);
});

// LVR Calculation Tests
test('LVR calculation: 20% deposit', 'calculation', () => {
  const price = 500000;
  const deposit = 100000;
  const loan = price - deposit;
  const lvr = (loan / price) * 100;
  assert(lvr === 80, `Expected 80%, got ${lvr}%`);
});

test('LVR calculation: 10% deposit', 'calculation', () => {
  const price = 600000;
  const deposit = 60000;
  const loan = price - deposit;
  const lvr = (loan / price) * 100;
  assert(lvr === 90, `Expected 90%, got ${lvr}%`);
});

// Yield Calculation Tests
test('Gross yield: $500k property, $26k annual rent', 'calculation', () => {
  const price = 500000;
  const rent = 26000;
  const yield_pct = (rent / price) * 100;
  assertApprox(yield_pct, 5.2, 0.01, `Expected 5.2%, got ${yield_pct.toFixed(2)}%`);
});

test('Gross yield: $800k property, $30k annual rent', 'calculation', () => {
  const price = 800000;
  const rent = 30000;
  const yield_pct = (rent / price) * 100;
  assertApprox(yield_pct, 3.75, 0.01, `Expected 3.75%, got ${yield_pct.toFixed(2)}%`);
});

// Depreciation Calculation Tests
test('Division 43 depreciation: $150k building value', 'calculation', () => {
  const buildingValue = 150000;
  const div43 = buildingValue * 0.025; // 2.5% per year
  assert(div43 === 3750, `Expected $3,750, got $${div43}`);
});

test('Total depreciation: Div 43 + Div 40', 'calculation', () => {
  const buildingValue = 200000;
  const div43 = buildingValue * 0.025;
  const div40 = 3000;
  const total = div43 + div40;
  assert(total === 8000, `Expected $8,000, got $${total}`);
});

// Tax Refund Calculation Tests
test('Tax refund: $10k loss at 30% rate', 'calculation', () => {
  const loss = 10000;
  const taxRate = 0.30;
  const refund = loss * taxRate;
  assert(refund === 3000, `Expected $3,000, got $${refund}`);
});

test('Tax refund: Negative gearing with depreciation', 'calculation', () => {
  const cashflowLoss = 5000;
  const depreciation = 5000;
  const taxRate = 0.37;
  const totalDeduction = cashflowLoss + depreciation;
  const refund = totalDeduction * taxRate;
  assert(refund === 3700, `Expected $3,700, got $${refund}`);
});

// Interest Calculation Tests (Amortization)
test('Annual interest: First year on $400k @ 6%', 'calculation', () => {
  const loan = 400000;
  const rate = 6 / 100 / 12;
  const monthlyPayment = loan * (rate / (1 - Math.pow(1 + rate, -360)));
  
  let balance = loan;
  let interestSum = 0;
  for(let i = 0; i < 12; i++) {
    const interest = balance * rate;
    const principal = monthlyPayment - interest;
    balance -= principal;
    interestSum += interest;
  }
  
  assertApprox(interestSum, 23856, 50, `Expected ~$23,856, got $${Math.round(interestSum)}`);
});

// DTI (Debt-to-Income) Calculation Tests
test('DTI calculation: 30% threshold', 'calculation', () => {
  const monthlyIncome = 8333; // $100k/year
  const monthlyRepayment = 2500;
  const dti = (monthlyRepayment / monthlyIncome) * 100;
  assertApprox(dti, 30, 0.1, `Expected 30%, got ${dti.toFixed(1)}%`);
});

test('DTI calculation: Multiple debts', 'calculation', () => {
  const monthlyIncome = 10000;
  const mortgage = 3000;
  const otherDebts = 500;
  const living = 3000;
  const total = mortgage + otherDebts + living;
  const dti = (total / monthlyIncome) * 100;
  assert(dti === 65, `Expected 65%, got ${dti}%`);
});

// Break-even Calculation Tests
test('Break-even: 3% growth, $500k property', 'calculation', () => {
  const purchasePrice = 500000;
  const stampDuty = 17990;
  const fees = 2500;
  const totalCost = purchasePrice + stampDuty + fees;
  const sellingCosts = purchasePrice * 0.03;
  const annualCosts = 30000; // holding costs
  
  // Find years to break even
  let years = 0;
  let futureValue = purchasePrice;
  while(years < 30 && (futureValue - sellingCosts) < totalCost + (annualCosts * years)) {
    years++;
    futureValue = purchasePrice * Math.pow(1.03, years);
  }
  
  assert(years >= 1 && years <= 10, `Expected 1-10 years, got ${years} years`);
});

// ============================================================================
// UI INTEGRATION TESTS - Test the actual calculator interface
// ============================================================================

test('UI: Calculator loads without JavaScript errors', 'ui', async () => {
  const calc = getCalculator();
  assert(calc.window, 'Calculator window should exist');
  assert(calc.$('price'), 'Price input should exist');
  assert(typeof calc.updateAll === 'function', 'updateAll function should exist');
  
  // Try to run updateAll and catch any errors
  try {
    calc.updateAll();
    await wait(100);
    assert(true, 'updateAll executed without errors');
  } catch(e) {
    throw new Error(`updateAll threw error: ${e.message}`);
  }
});

test('UI: All critical functions are defined', 'ui', async () => {
  const calc = getCalculator();
  assert(typeof calc.updateAll === 'function', 'updateAll should be a function');
  assert(typeof calc.updateBuyerCalcs === 'function', 'updateBuyerCalcs should be a function');
  assert(typeof calc.updateCapitalAppreciation === 'function', 'updateCapitalAppreciation should be a function');
  assert(typeof calc.window.calcNSWDuty === 'function', 'calcNSWDuty should be a function');
  assert(typeof calc.window.drawChart === 'function', 'drawChart should be a function');
});

test('UI: Output elements exist and are populated', 'ui', async () => {
  const calc = getCalculator();
  calc.updateAll();
  await wait(200);
  
  const criticalOutputs = [
    'out_deposit', 'out_stamp', 'out_fees', 'out_upfront', 'out_loan',
    'out_monthly', 'out_rent_annual', 'out_opcosts', 'out_cashflow',
    'out_gross_yield', 'out_net_yield', 'out_depreciation', 'out_tax_refund'
  ];
  
  for(const id of criticalOutputs) {
    const el = calc.$(id);
    assert(el, `Output element '${id}' should exist`);
    const text = el.innerText;
    assert(text && text.length > 0, `Output '${id}' should have content, got: "${text}"`);
    assert(!text.includes('NaN'), `Output '${id}' should not contain NaN, got: "${text}"`);
    assert(!text.includes('undefined'), `Output '${id}' should not contain undefined, got: "${text}"`);
  }
});

test('UI: Analysis text is populated correctly', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('rent_week').value = 500;
  calc.updateAll();
  await wait(200);
  
  const analysisText = calc.$('analysis_text').innerText;
  assert(analysisText.length > 0, 'Analysis text should not be empty');
  assert(analysisText.includes('$'), 'Analysis text should contain dollar amounts');
  assert(!analysisText.includes('NaN'), `Analysis should not contain NaN, got: "${analysisText}"`);
  assert(!analysisText.includes('undefined'), `Analysis should not contain undefined, got: "${analysisText}"`);
});

test('UI: Multiple consecutive updates work correctly', 'ui', async () => {
  const calc = getCalculator();
  
  // First update
  calc.$('price').value = 400000;
  calc.updateAll();
  await wait(100);
  
  let stamp1 = calc.$('out_stamp').innerText;
  assert(!stamp1.includes('NaN'), `First update stamp duty invalid: "${stamp1}"`);
  
  // Second update with different value
  calc.$('price').value = 600000;
  calc.updateAll();
  await wait(100);
  
  let stamp2 = calc.$('out_stamp').innerText;
  assert(!stamp2.includes('NaN'), `Second update stamp duty invalid: "${stamp2}"`);
  assert(stamp1 !== stamp2, 'Stamp duty should change when price changes');
});

test('UI: Console errors are detected during calculations', 'ui', async () => {
  const calc = getCalculator();
  const originalConsoleError = calc.window.console.error;
  let errorCaught = false;
  let errorMessage = '';
  
  // Override console.error to catch any errors
  calc.window.console.error = function(...args) {
    errorCaught = true;
    errorMessage = args.join(' ');
    originalConsoleError.apply(calc.window.console, args);
  };
  
  try {
    calc.$('price').value = 500000;
    calc.updateAll();
    await wait(200);
    
    assert(!errorCaught, `Console error detected: ${errorMessage}`);
  } finally {
    calc.window.console.error = originalConsoleError;
  }
});

test('UI: No undefined values in any output', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('rent_week').value = 500;
  calc.$('deposit_percent').value = 20;
  calc.$('interest_rate').value = 6.5;
  calc.updateAll();
  await wait(200);
  
  // Get all output elements
  const outputs = calc.document.querySelectorAll('[id^="out_"]');
  const failures = [];
  
  outputs.forEach(el => {
    const text = el.innerText;
    if (text.includes('undefined') || text.includes('NaN') || text === '') {
      failures.push(`${el.id}: "${text}"`);
    }
  });
  
  assert(failures.length === 0, `Found invalid outputs: ${failures.join(', ')}`);
});

test('UI: Chart renders after calculation', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.updateAll();
  await wait(300);
  
  assert(calc.window.chartInstance, 'Chart instance should exist after updateAll');
  assert(calc.window.chartInstance.data, 'Chart should have data');
  assert(calc.window.chartInstance.data.datasets.length > 0, 'Chart should have datasets');
});

test('UI: REGRESSION - Analysis calculation uses computed values not DOM reads', 'ui', async () => {
  const calc = getCalculator();
  
  // This test specifically checks for the bug where analysis tried to read
  // out_loan and out_opcosts before they were calculated
  calc.$('price').value = 550000;
  calc.$('rent_week').value = 520;
  calc.$('deposit_percent').value = 25;
  
  // Clear the outputs first to simulate a fresh calculation
  calc.$('out_loan').innerText = '';
  calc.$('out_opcosts').innerText = '';
  
  // Run calculation
  calc.updateAll();
  await wait(200);
  
  // Analysis should still work even if DOM was empty before calculation
  const analysisText = calc.$('analysis_text').innerText;
  assert(analysisText.length > 0, 'Analysis should be populated');
  assert(analysisText.includes('$'), 'Analysis should contain dollar amount');
  assert(!analysisText.includes('$0'), 'Analysis should not show $0 (indicates failed to read values)');
  assert(!analysisText.includes('NaN'), 'Analysis should not contain NaN');
  
  // Verify the outputs are actually populated
  const loanText = calc.$('out_loan').innerText;
  const opCostsText = calc.$('out_opcosts').innerText;
  assert(loanText && loanText !== '', 'Loan amount should be populated');
  assert(opCostsText && opCostsText !== '', 'Operating costs should be populated');
});

test('UI: Fresh page load calculates everything correctly', 'ui', async () => {
  // This simulates what happens when a user first loads the page
  const calc = getCalculator();
  
  // Don't touch any inputs - use defaults
  // The window.onload should have triggered updateAll()
  await wait(500);
  
  // Check that all key outputs are populated
  const criticalOutputs = ['out_deposit', 'out_stamp', 'out_loan', 'out_monthly', 'out_cashflow'];
  
  for(const id of criticalOutputs) {
    const text = calc.$(id).innerText;
    assert(text && text !== '$0' && text !== '', `${id} should be calculated on load, got: "${text}"`);
    assert(!text.includes('NaN'), `${id} should not contain NaN on load`);
  }
  
  // Analysis should also be populated
  const analysisText = calc.$('analysis_text').innerText;
  assert(analysisText.length > 10, 'Analysis should be populated on load');
});

test('UI: Default values load correctly', 'ui', async () => {
  const calc = getCalculator();
  
  // First ensure updateAll runs without error
  try {
    calc.updateAll();
    await wait(200);
  } catch(e) {
    throw new Error(`updateAll failed: ${e.message}`);
  }
  
  const price = calc.$('price').value;
  assert(price == 650000, `Expected default price 650000, got ${price}`);
  
  // Verify outputs were actually calculated
  const depositText = calc.$('out_deposit').innerText;
  assert(depositText && !depositText.includes('NaN'), `Deposit should be valid, got: "${depositText}"`);
});

test('VALIDATION: All input fields have valid default values', 'ui', async () => {
  const calc = getCalculator();
  await wait(300);
  
  const requiredInputs = {
    'price': { min: 100000, name: 'Property Price' },
    'rent_week': { min: 1, name: 'Weekly Rent' },
    'strata_qtr': { min: 0, name: 'Strata Fees' },
    'deposit_percent': { min: 0, max: 100, name: 'Deposit %' },
    'interest_rate': { min: 0, max: 30, name: 'Interest Rate' },
    'loan_term': { min: 1, max: 40, name: 'Loan Term' },
    'legal_fee': { min: 0, name: 'Legal Fees' },
    'inspection_fee': { min: 0, name: 'Inspection Fee' },
    'loan_fees': { min: 0, name: 'Loan Fees' },
    'pm_pct': { min: 0, max: 100, name: 'Property Management %' },
    'maintenance': { min: 0, name: 'Maintenance' }
  };
  
  const failures = [];
  for(const [id, config] of Object.entries(requiredInputs)) {
    const el = calc.$(id);
    if(!el) {
      failures.push(`Missing input: ${config.name} (${id})`);
      continue;
    }
    
    const value = Number(el.value);
    if(isNaN(value)) {
      failures.push(`${config.name}: value is NaN`);
    } else if(config.min !== undefined && value < config.min) {
      failures.push(`${config.name}: ${value} < minimum ${config.min}`);
    } else if(config.max !== undefined && value > config.max) {
      failures.push(`${config.name}: ${value} > maximum ${config.max}`);
    }
  }
  
  assert(failures.length === 0, `Invalid input defaults:\n${failures.join('\n')}`);
});

test('VALIDATION: All outputs show calculated values not zeros', 'ui', async () => {
  const calc = getCalculator();
  calc.updateAll();
  await wait(300);
  
  const criticalOutputs = {
    'out_deposit': 'Deposit',
    'out_stamp': 'Stamp Duty',
    'out_fees': 'Fees',
    'out_upfront': 'Total Upfront',
    'out_loan': 'Loan Amount',
    'out_monthly': 'Monthly Repayment',
    'out_rent_annual': 'Annual Rent',
    'out_opcosts': 'Operating Costs',
    'out_cashflow': 'Cashflow'
  };
  
  const failures = [];
  for(const [id, name] of Object.entries(criticalOutputs)) {
    const el = calc.$(id);
    if(!el) {
      failures.push(`Missing output: ${name} (${id})`);
      continue;
    }
    
    const text = el.innerText;
    if(!text || text === '' || text === '$0' || text === '0') {
      failures.push(`${name}: shows zero or empty ("${text}")`);
    } else if(text.includes('NaN') || text.includes('undefined')) {
      failures.push(`${name}: contains invalid value ("${text}")`);
    }
  }
  
  assert(failures.length === 0, `Invalid outputs:\n${failures.join('\n')}`);
});

test('VALIDATION: Outputs match expected calculations for defaults', 'ui', async () => {
  const calc = getCalculator();
  
  // Reset to known defaults
  calc.$('price').value = 650000;
  calc.$('rent_week').value = 500;
  calc.$('deposit_percent').value = 20;
  calc.$('interest_rate').value = 6.0;
  calc.$('loan_term').value = 30;
  calc.updateAll();
  await wait(200);
  
  // Expected values based on defaults
  const deposit = 650000 * 0.20; // 130,000
  const depositText = calc.$('out_deposit').innerText;
  const depositActual = parseInt(depositText.replace(/[^0-9]/g, ''));
  assert(depositActual === 130000, `Expected deposit $130,000, got $${depositActual}`);
  
  // Stamp duty for $650k in NSW
  const stampText = calc.$('out_stamp').innerText;
  const stampActual = parseInt(stampText.replace(/[^0-9]/g, ''));
  assertApprox(stampActual, 25490, 50, `Expected stamp duty ~$25,490, got $${stampActual}`);
  
  // Loan amount
  const loanText = calc.$('out_loan').innerText;
  const loanActual = parseInt(loanText.replace(/[^0-9]/g, ''));
  assert(loanActual === 520000, `Expected loan $520,000, got $${loanActual}`);
  
  // Monthly repayment for $520k @ 6% for 30 years
  const monthlyText = calc.$('out_monthly').innerText;
  const monthlyActual = parseInt(monthlyText.replace(/[^0-9]/g, ''));
  assertApprox(monthlyActual, 3118, 20, `Expected monthly ~$3,118, got $${monthlyActual}`);
  
  // Annual rent
  const rentText = calc.$('out_rent_annual').innerText;
  const rentActual = parseInt(rentText.replace(/[^0-9]/g, ''));
  assert(rentActual === 26000, `Expected annual rent $26,000, got $${rentActual}`);
});

test('VALIDATION: Input-output consistency check', 'ui', async () => {
  const calc = getCalculator();
  
  // Set specific values
  calc.$('price').value = 500000;
  calc.$('deposit_percent').value = 20;
  calc.updateAll();
  await wait(200);
  
  const price = Number(calc.$('price').value);
  const depositPct = Number(calc.$('deposit_percent').value);
  
  const expectedDeposit = Math.round(price * (depositPct / 100));
  const depositText = calc.$('out_deposit').innerText;
  const actualDeposit = parseInt(depositText.replace(/[^0-9]/g, ''));
  
  assert(actualDeposit === expectedDeposit, 
         `Deposit calculation error: ${depositPct}% of $${price} should be $${expectedDeposit}, got $${actualDeposit}`);
  
  const expectedLoan = price - expectedDeposit;
  const loanText = calc.$('out_loan').innerText;
  const actualLoan = parseInt(loanText.replace(/[^0-9]/g, ''));
  
  assert(actualLoan === expectedLoan,
         `Loan calculation error: $${price} - $${expectedDeposit} should be $${expectedLoan}, got $${actualLoan}`);
});

test('CRITICAL: No all-zeros bug - page load must calculate', 'ui', async () => {
  const calc = getCalculator();
  
  // Wait for page load calculations
  await wait(500);
  
  // Check that we don't have the "all zeros" bug
  const outputsToCheck = ['out_deposit', 'out_stamp', 'out_loan', 'out_monthly', 'out_rent_annual', 'out_opcosts'];
  const allZeros = [];
  const hasValues = [];
  
  for(const id of outputsToCheck) {
    const text = calc.$(id).innerText;
    const numValue = parseInt(text.replace(/[^0-9]/g, '')) || 0;
    
    if(numValue === 0) {
      allZeros.push(id);
    } else {
      hasValues.push(`${id}=${text}`);
    }
  }
  
  // If more than half the outputs are zero, we have the bug
  assert(allZeros.length < 3, 
         `All-zeros bug detected! ${allZeros.length} outputs are $0: ${allZeros.join(', ')}.\nNon-zero values: ${hasValues.join(', ')}`);
  
  // Specifically check that key outputs are non-zero
  const depositText = calc.$('out_deposit').innerText;
  const deposit = parseInt(depositText.replace(/[^0-9]/g, ''));
  assert(deposit > 0, `Deposit should not be $0, got "${depositText}"`);
  
  const loanText = calc.$('out_loan').innerText;
  const loan = parseInt(loanText.replace(/[^0-9]/g, ''));
  assert(loan > 0, `Loan should not be $0, got "${loanText}"`);
});

test('UI: Stamp duty updates on price change', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 600000;
  calc.updateAll();
  await wait(100);
  
  const stampText = calc.$('out_stamp').innerText;
  const stamp = parseInt(stampText.replace(/[^0-9]/g, ''));
  assertApprox(stamp, 21490, 50, `Expected ~$21,490 stamp duty, got $${stamp.toLocaleString()}`);
});

test('UI: Deposit percentage correctly calculates deposit amount', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('deposit_percent').value = 20;
  calc.updateAll();
  await wait(100);
  
  const depositText = calc.$('out_deposit').innerText;
  const deposit = parseInt(depositText.replace(/[^0-9]/g, ''));
  assert(deposit === 100000, `Expected $100,000 deposit, got $${deposit.toLocaleString()}`);
});

test('UI: LMI checkbox auto-enables when deposit < 20%', 'ui', async () => {
  const calc = getCalculator();
  calc.$('deposit_percent').value = 15;
  calc.updateAll();
  await wait(100);
  
  const lmiChecked = calc.$('include_lmi').checked;
  assert(lmiChecked, 'LMI checkbox should be auto-checked for deposit < 20%');
});

test('UI: Gross yield calculation displays correctly', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('rent_week').value = 500; // $26k/year
  calc.updateAll();
  await wait(100);
  
  const yieldText = calc.$('out_gross_yield').innerText;
  const yieldValue = parseFloat(yieldText);
  assertApprox(yieldValue, 5.2, 0.1, `Expected ~5.2% yield, got ${yieldValue}%`);
});

test('UI: Monthly repayment calculates correctly', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 400000;
  calc.$('deposit_percent').value = 20;
  calc.$('interest_rate').value = 6.0;
  calc.$('loan_term').value = 30;
  calc.updateAll();
  await wait(100);
  
  const repayText = calc.$('out_monthly').innerText;
  const repay = parseInt(repayText.replace(/[^0-9]/g, ''));
  assertApprox(repay, 1919, 20, `Expected ~$1,919/month, got $${repay.toLocaleString()}`);
});

test('UI: Negative cashflow displays with correct styling', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 600000;
  calc.$('rent_week').value = 400; // Low rent
  calc.$('interest_rate').value = 7.0;
  calc.updateAll();
  await wait(100);
  
  const cashflowEl = calc.$('out_cashflow');
  const hasNegativeClass = cashflowEl.classList.contains('negative');
  assert(hasNegativeClass, 'Negative cashflow should have "negative" class');
});

test('UI: Depreciation checkbox toggles calculation', 'ui', async () => {
  const calc = getCalculator();
  calc.$('include_depreciation').checked = false;
  calc.updateAll();
  await wait(100);
  
  let depText = calc.$('out_depreciation').innerText;
  let dep = parseInt(depText.replace(/[^0-9]/g, '')) || 0;
  assert(dep === 0, `Expected $0 depreciation when unchecked, got $${dep}`);
  
  calc.$('include_depreciation').checked = true;
  calc.$('building_value').value = 200000;
  calc.updateAll();
  await wait(100);
  
  depText = calc.$('out_depreciation').innerText;
  dep = parseInt(depText.replace(/[^0-9]/g, ''));
  assert(dep > 0, `Expected depreciation > $0 when checked, got $${dep}`);
});

test('UI: Tax refund calculates with negative gearing', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 700000;
  calc.$('rent_week').value = 400;
  calc.$('deposit_percent').value = 20;
  calc.$('interest_rate').value = 6.5;
  calc.$('taxBracket').value = 0.37;
  calc.$('include_depreciation').checked = true;
  calc.$('building_value').value = 200000;
  calc.updateAll();
  await wait(100);
  
  const refundText = calc.$('out_tax_refund').innerText;
  const refund = parseInt(refundText.replace(/[^0-9]/g, ''));
  assert(refund > 0, `Expected tax refund > $0 with negative gearing, got $${refund}`);
});

test('UI: Capital appreciation chart updates on price change', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 750000;
  calc.$('capital_gain').value = 4;
  calc.updateCapitalAppreciation();
  await wait(200);
  
  assert(calc.window.valueChartInstance, 'Capital appreciation chart should exist');
  const chartData = calc.window.valueChartInstance.data.datasets[0].data;
  assert(chartData.length === 21, `Expected 21 data points, got ${chartData.length}`);
  assert(chartData[0] === 750000, `Expected first value 750000, got ${chartData[0]}`);
});

// Buyer/Affordability Tab Tests
test('UI Buyer: DTI calculation shows correct ratio', 'ui', async () => {
  const calc = getCalculator();
  
  // Switch to buyer tab
  const buyerTab = calc.document.querySelector('[data-tab="affordability"]');
  if (buyerTab) {
    buyerTab.click();
    await wait(200);
    
    calc.$('buyer_price').value = 500000;
    calc.$('buyer_deposit_amount').value = 100000;
    calc.$('buyer_income').value = 120000;
    calc.$('buyer_living_expenses').value = 3000;
    calc.$('buyer_other_debts').value = 500;
    calc.$('buyer_interest_rate').value = 6.5;
    calc.updateBuyerCalcs();
    await wait(100);
    
    const dtiText = calc.$('buyer_out_dti').innerText;
    const dti = parseFloat(dtiText);
    assert(dti > 0 && dti < 100, `Expected valid DTI percentage, got ${dti}%`);
  }
});

test('UI Buyer: Shortfall detection works correctly', 'ui', async () => {
  const calc = getCalculator();
  
  const buyerTab = calc.document.querySelector('[data-tab="affordability"]');
  if (buyerTab) {
    buyerTab.click();
    await wait(200);
    
    calc.$('buyer_price').value = 600000;
    calc.$('buyer_deposit_amount').value = 50000; // Insufficient
    calc.updateBuyerCalcs();
    await wait(100);
    
    const shortfallEl = calc.$('buyer_out_shortfall');
    const hasNegative = shortfallEl.classList.contains('negative');
    assert(hasNegative, 'Should show negative/shortfall when deposit is insufficient');
  }
});

test('UI Buyer: Break-even calculation completes', 'ui', async () => {
  const calc = getCalculator();
  
  const buyerTab = calc.document.querySelector('[data-tab="affordability"]');
  if (buyerTab) {
    buyerTab.click();
    await wait(200);
    
    calc.$('buyer_price').value = 500000;
    calc.$('buyer_deposit_amount').value = 100000;
    calc.updateBuyerCalcs();
    await wait(100);
    
    const yearsText = calc.$('buyer_out_breakeven_years').innerText;
    assert(yearsText.includes('year'), `Expected break-even years, got "${yearsText}"`);
  }
});

test('UI Buyer: Serviceability check with high DTI', 'ui', async () => {
  const calc = getCalculator();
  
  const buyerTab = calc.document.querySelector('[data-tab="affordability"]');
  if (buyerTab) {
    buyerTab.click();
    await wait(200);
    
    // High debt scenario
    calc.$('buyer_price').value = 800000;
    calc.$('buyer_deposit_amount').value = 160000;
    calc.$('buyer_income').value = 100000; // Low income relative to loan
    calc.$('buyer_living_expenses').value = 4000;
    calc.updateBuyerCalcs();
    await wait(100);
    
    const dtiText = calc.$('buyer_out_dti').innerText;
    const dti = parseFloat(dtiText);
    assert(dti > 30, `Expected DTI > 30% for high debt scenario, got ${dti}%`);
    
    const serviceText = calc.$('buyer_out_serviceable').innerText;
    assert(serviceText.includes('Warning') || serviceText.includes('High'), 
           `Expected serviceability warning, got "${serviceText}"`);
  }
});

test('UI Buyer: Surplus funds with low debt', 'ui', async () => {
  const calc = getCalculator();
  
  const buyerTab = calc.document.querySelector('[data-tab="affordability"]');
  if (buyerTab) {
    buyerTab.click();
    await wait(200);
    
    // Low debt scenario
    calc.$('buyer_price').value = 400000;
    calc.$('buyer_deposit_amount').value = 100000;
    calc.$('buyer_income').value = 150000; // High income
    calc.$('buyer_living_expenses').value = 2500;
    calc.$('buyer_other_debts').value = 0;
    calc.updateBuyerCalcs();
    await wait(100);
    
    const surplusText = calc.$('buyer_out_monthly_surplus').innerText;
    const surplus = parseInt(surplusText.replace(/[^0-9-]/g, ''));
    assert(surplus > 0, `Expected positive surplus with high income, got $${surplus}`);
  }
});

test('UI Buyer: All outputs populated on tab switch', 'ui', async () => {
  const calc = getCalculator();
  
  const buyerTab = calc.document.querySelector('[data-tab="affordability"]');
  if (buyerTab) {
    buyerTab.click();
    await wait(300);
    
    // Check all buyer outputs exist and are populated
    const buyerOutputs = ['buyer_out_total_price', 'buyer_out_loan', 'buyer_out_monthly', 
                         'buyer_out_dti', 'buyer_out_shortfall'];
    
    for(const id of buyerOutputs) {
      const el = calc.$(id);
      if (el) {
        const text = el.innerText;
        assert(text && text.length > 0, `${id} should have content`);
        assert(!text.includes('NaN'), `${id} should not contain NaN`);
      }
    }
  }
});

test('UI Buyer: Stress rate calculation increases repayment', 'ui', async () => {
  const calc = getCalculator();
  
  const buyerTab = calc.document.querySelector('[data-tab="affordability"]');
  if (buyerTab) {
    buyerTab.click();
    await wait(200);
    
    calc.$('buyer_price').value = 500000;
    calc.$('buyer_deposit_amount').value = 100000;
    calc.$('buyer_interest_rate').value = 6.0;
    calc.$('buyer_stress_rate').value = 8.5; // Stress rate higher
    calc.updateBuyerCalcs();
    await wait(100);
    
    const stressRepayText = calc.$('buyer_out_stress_repay').innerText;
    const stressRepay = parseInt(stressRepayText.replace(/[^0-9]/g, ''));
    
    const monthlyText = calc.$('buyer_out_monthly').innerText;
    const monthly = parseInt(monthlyText.replace(/[^0-9]/g, ''));
    
    assert(stressRepay > monthly, 
           `Stress repayment ($${stressRepay}) should be > actual ($${monthly})`);
  }
});

// ============================================================================
// EDGE CASE AND VALIDATION TESTS
// ============================================================================

test('Edge Case: Zero price', 'calculation', () => {
  const calc = getCalculator();
  const duty = calc.window.calcNSWDuty(0);
  assert(duty === 0, `Expected $0 duty for $0 price, got $${duty}`);
});

test('Edge Case: Extremely high price', 'calculation', () => {
  const calc = getCalculator();
  const duty = calc.window.calcNSWDuty(5000000);
  assert(duty > 0, `Should calculate duty for $5M property`);
  assert(duty > 200000, `$5M property duty should be > $200k, got $${duty}`);
});

test('Edge Case: Very low interest rate', 'calculation', () => {
  const calc = getCalculator();
  const P = 500000;
  const r = 0.01 / 100 / 12; // 0.01% annual
  const n = 30 * 12;
  
  if (r === 0) {
    return; // Skip if exactly zero
  }
  
  const M = P * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
  assert(!isNaN(M), 'Should handle very low interest rates');
  assert(M > 0, 'Payment should be positive');
});

test('Edge Case: Very high interest rate', 'calculation', () => {
  const calc = getCalculator();
  const P = 500000;
  const r = 20 / 100 / 12; // 20% annual
  const n = 30 * 12;
  
  const M = P * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
  assert(!isNaN(M), 'Should handle high interest rates');
  assert(M > 8000, 'Monthly payment should be very high (>$8k)');
});

test('Edge Case: Very short loan term', 'calculation', () => {
  const calc = getCalculator();
  const P = 400000;
  const r = 6 / 100 / 12;
  const n = 5 * 12; // 5 years
  
  const M = P * (r * Math.pow(1 + r, n)) / (Math.pow(1 + r, n) - 1);
  assert(!isNaN(M), 'Should handle short loan terms');
  assert(M > 7000, 'Short term = high monthly payment (>$7k)');
});

test('Edge Case: Negative rent (invalid input)', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('rent_week').value = -100;
  calc.updateAll();
  await wait(100);
  
  // Should not crash, should handle gracefully
  const yieldText = calc.$('out_gross_yield').innerText;
  assert(!yieldText.includes('NaN'), 'Should handle negative rent gracefully');
});

test('Edge Case: 100% deposit', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('deposit_percent').value = 100;
  calc.updateAll();
  await wait(100);
  
  const loanText = calc.$('out_loan').innerText;
  const loan = parseInt(loanText.replace(/[^0-9]/g, '')) || 0;
  assert(loan === 0, `Expected $0 loan with 100% deposit, got $${loan}`);
  
  const monthlyText = calc.$('out_monthly').innerText;
  const monthly = parseInt(monthlyText.replace(/[^0-9]/g, '')) || 0;
  assert(monthly === 0, `Expected $0 monthly payment with 100% deposit, got $${monthly}`);
});

test('Edge Case: 0% deposit', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('deposit_percent').value = 0;
  calc.updateAll();
  await wait(100);
  
  const loanText = calc.$('out_loan').innerText;
  const loan = parseInt(loanText.replace(/[^0-9]/g, ''));
  assert(loan === 500000, `Expected $500k loan with 0% deposit, got $${loan}`);
});

test('Validation: All outputs are numbers or currency', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 550000;
  calc.updateAll();
  await wait(200);
  
  const outputs = calc.document.querySelectorAll('[id^="out_"]');
  const invalidOutputs = [];
  
  outputs.forEach(el => {
    const text = el.innerText;
    // Skip empty or dash values
    if (text === '' || text === '-' || text === 'N/A') return;
    
    // Check for invalid patterns
    if (text.includes('undefined') || text.includes('NaN') || text.includes('Infinity')) {
      invalidOutputs.push(`${el.id}: "${text}"`);
    }
  });
  
  assert(invalidOutputs.length === 0, `Invalid outputs found: ${invalidOutputs.join(', ')}`);
});

test('Validation: Percentage outputs are in valid range', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('rent_week').value = 500;
  calc.updateAll();
  await wait(100);
  
  const yieldText = calc.$('out_gross_yield').innerText;
  const yieldValue = parseFloat(yieldText);
  assert(yieldValue >= 0 && yieldValue <= 100, `Yield should be 0-100%, got ${yieldValue}%`);
  
  const netYieldText = calc.$('out_net_yield').innerText;
  const netYieldValue = parseFloat(netYieldText);
  assert(netYieldValue >= -50 && netYieldValue <= 100, `Net yield should be reasonable, got ${netYieldValue}%`);
});

test('Validation: LVR calculation is within bounds', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 600000;
  calc.$('deposit_percent').value = 25;
  calc.updateAll();
  await wait(100);
  
  const lvrText = calc.$('out_lvr').innerText;
  const lvr = parseFloat(lvrText);
  assert(lvr >= 0 && lvr <= 100, `LVR should be 0-100%, got ${lvr}%`);
  assert(lvr === 75, `Expected 75% LVR with 25% deposit, got ${lvr}%`);
});

// ============================================================================
// TAB SWITCHING AND UI INTERACTION TESTS
// ============================================================================

test('UI Interaction: Tab switching works between Investment and Affordability', 'ui', async () => {
  const calc = getCalculator();
  
  const investmentTab = calc.document.querySelector('[data-tab="investment"]');
  const affordabilityTab = calc.document.querySelector('[data-tab="affordability"]');
  
  assert(investmentTab, 'Investment tab button should exist');
  assert(affordabilityTab, 'Affordability tab button should exist');
  
  // Switch to affordability
  affordabilityTab.click();
  await wait(300);
  
  const affordabilityContent = calc.$('tab-affordability');
  assert(affordabilityContent.classList.contains('active'), 'Affordability tab content should be active');
  
  // Switch back to investment
  investmentTab.click();
  await wait(300);
  
  const investmentContent = calc.$('tab-investment');
  assert(investmentContent.classList.contains('active'), 'Investment tab content should be active');
});

test('UI Interaction: Collapsible sections expand and collapse', 'ui', async () => {
  const calc = getCalculator();
  
  const headers = calc.document.querySelectorAll('.section-header');
  assert(headers.length > 0, 'Should have collapsible section headers');
  
  const firstHeader = headers[0];
  const firstBody = firstHeader.nextElementSibling;
  
  // Initially should be expanded
  const initialDisplay = window.getComputedStyle(firstBody).display;
  
  // Click to toggle
  firstHeader.click();
  await wait(100);
  
  const afterClick = window.getComputedStyle(firstBody).display;
  assert(initialDisplay !== afterClick, 'Clicking header should toggle section visibility');
});

test('UI Interaction: Calculate button triggers update', 'ui', async () => {
  const calc = getCalculator();
  
  calc.$('price').value = 777777;
  calc.$('calcBtn').click();
  await wait(200);
  
  const stampText = calc.$('out_stamp').innerText;
  assert(!stampText.includes('NaN'), 'Calculate button should trigger valid calculation');
  assert(stampText.length > 0, 'Calculate button should populate outputs');
});

test('UI Interaction: Reset button restores defaults', 'ui', async () => {
  const calc = getCalculator();
  
  // Change values
  calc.$('price').value = 999999;
  calc.$('rent_week').value = 999;
  calc.updateAll();
  await wait(100);
  
  // Reset
  calc.document.getElementById('resetBtn').click();
  await wait(200);
  
  const price = calc.$('price').value;
  assert(price == 650000, `Expected default price 650000 after reset, got ${price}`);
  
  const rent = calc.$('rent_week').value;
  assert(rent == 500, `Expected default rent 500 after reset, got ${rent}`);
  
  // Verify calculation ran after reset
  const depositText = calc.$('out_deposit').innerText;
  const deposit = parseInt(depositText.replace(/[^0-9]/g, ''));
  assert(deposit === 130000, `Expected deposit $130,000 after reset, got $${deposit}`);
});

test('VALIDATION: Reset button matches HTML defaults', 'ui', async () => {
  const calc = getCalculator();
  
  // Get HTML default values
  const htmlDefaults = {
    price: Number(calc.$('price').defaultValue) || Number(calc.$('price').getAttribute('value')),
    rent_week: Number(calc.$('rent_week').defaultValue) || Number(calc.$('rent_week').getAttribute('value')),
    deposit_percent: Number(calc.$('deposit_percent').defaultValue) || Number(calc.$('deposit_percent').getAttribute('value')),
    interest_rate: Number(calc.$('interest_rate').defaultValue) || Number(calc.$('interest_rate').getAttribute('value'))
  };
  
  // Click reset
  calc.document.getElementById('resetBtn').click();
  await wait(200);
  
  // Get reset values
  const resetValues = {
    price: Number(calc.$('price').value),
    rent_week: Number(calc.$('rent_week').value),
    deposit_percent: Number(calc.$('deposit_percent').value),
    interest_rate: Number(calc.$('interest_rate').value)
  };
  
  // Compare
  const mismatches = [];
  for(const [key, htmlValue] of Object.entries(htmlDefaults)) {
    const resetValue = resetValues[key];
    if(htmlValue && resetValue && htmlValue !== resetValue) {
      mismatches.push(`${key}: HTML default=${htmlValue}, Reset sets=${resetValue}`);
    }
  }
  
  assert(mismatches.length === 0, 
         `Reset button doesn't match HTML defaults:\n${mismatches.join('\n')}`);
});

test('UI Interaction: PDF button exists and is clickable', 'ui', async () => {
  const calc = getCalculator();
  
  const pdfBtn = calc.document.getElementById('pdfBtn');
  assert(pdfBtn, 'PDF button should exist');
  assert(!pdfBtn.disabled, 'PDF button should not be disabled');
  
  // Note: We don't actually click it because jsPDF might not work in test iframe
  // But we verify the button and its handler exist
});

// ============================================================================
// CHART TESTS
// ============================================================================

test('Chart: Cashflow chart renders with correct data', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('rent_week').value = 500;
  calc.updateAll();
  await wait(300);
  
  assert(calc.window.chartInstance, 'Cashflow chart instance should exist');
  const chart = calc.window.chartInstance;
  assert(chart.data.labels.length > 0, 'Chart should have labels');
  assert(chart.data.datasets.length > 0, 'Chart should have datasets');
  
  // Check for expected labels
  const labels = chart.data.labels;
  assert(labels.includes('Rental Income'), 'Chart should include Rental Income');
  assert(labels.includes('Loan Repayment'), 'Chart should include Loan Repayment');
});

test('Chart: Capital appreciation chart has 20-year projection', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 600000;
  calc.$('capital_gain').value = 4;
  calc.updateCapitalAppreciation();
  await wait(300);
  
  assert(calc.window.valueChartInstance, 'Capital appreciation chart should exist');
  const chart = calc.window.valueChartInstance;
  const data = chart.data.datasets[0].data;
  
  assert(data.length === 21, `Expected 21 years (0-20), got ${data.length}`);
  assert(data[0] === 600000, `Year 0 should be $600k, got $${data[0]}`);
  
  // Check that values increase with positive growth
  assert(data[20] > data[0], 'Property value should increase over 20 years');
});

test('Chart: Negative capital growth works correctly', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('capital_gain').value = -2; // Negative growth
  calc.updateCapitalAppreciation();
  await wait(300);
  
  const chart = calc.window.valueChartInstance;
  const data = chart.data.datasets[0].data;
  
  assert(data[20] < data[0], 'Property value should decrease with negative growth');
  assert(data[20] > 0, 'Property value should remain positive');
});

test('Chart: Zero capital growth maintains constant value', 'ui', async () => {
  const calc = getCalculator();
  calc.$('price').value = 500000;
  calc.$('capital_gain').value = 0;
  calc.updateCapitalAppreciation();
  await wait(300);
  
  const chart = calc.window.valueChartInstance;
  const data = chart.data.datasets[0].data;
  
  assert(data[0] === 500000, 'Year 0 should be $500k');
  assert(data[20] === 500000, 'Year 20 should remain $500k with 0% growth');
});

// ============================================================================
// STRESS TESTS AND REAL-WORLD SCENARIOS
// ============================================================================

test('Stress: Rapid consecutive updates', 'ui', async () => {
  const calc = getCalculator();
  
  for (let i = 0; i < 10; i++) {
    calc.$('price').value = 400000 + (i * 50000);
    calc.updateAll();
  }
  
  await wait(300);
  
  const stampText = calc.$('out_stamp').innerText;
  assert(!stampText.includes('NaN'), 'Should handle rapid updates without errors');
});

test('Stress: Switching tabs repeatedly', 'ui', async () => {
  const calc = getCalculator();
  
  const investmentTab = calc.document.querySelector('[data-tab="investment"]');
  const affordabilityTab = calc.document.querySelector('[data-tab="affordability"]');
  
  for (let i = 0; i < 5; i++) {
    affordabilityTab.click();
    await wait(100);
    investmentTab.click();
    await wait(100);
  }
  
  // Should still work
  calc.updateAll();
  await wait(200);
  
  const stampText = calc.$('out_stamp').innerText;
  assert(!stampText.includes('NaN'), 'Should handle repeated tab switching');
});

test('Real-world: Sydney median house price scenario', 'ui', async () => {
  const calc = getCalculator();
  
  // Sydney median ~$1.4M, rental yield ~2.5%
  calc.$('price').value = 1400000;
  calc.$('rent_week').value = 700; // ~2.6% yield
  calc.$('deposit_percent').value = 20;
  calc.$('interest_rate').value = 6.5;
  calc.updateAll();
  await wait(200);
  
  const stampText = calc.$('out_stamp').innerText;
  const stamp = parseInt(stampText.replace(/[^0-9]/g, ''));
  assert(stamp > 60000, `Expected high stamp duty for $1.4M, got $${stamp}`);
  
  const cashflowEl = calc.$('out_cashflow');
  const isNegative = cashflowEl.classList.contains('negative');
  assert(isNegative, 'Sydney median should show negative cashflow (low yield)');
});

test('Real-world: Regional high-yield property', 'ui', async () => {
  const calc = getCalculator();
  
  // Regional property: $350k with 6% yield
  calc.$('price').value = 350000;
  calc.$('rent_week').value = 400; // ~6% yield
  calc.$('deposit_percent').value = 20;
  calc.$('interest_rate').value = 6.5;
  calc.updateAll();
  await wait(200);
  
  const yieldText = calc.$('out_gross_yield').innerText;
  const yieldValue = parseFloat(yieldText);
  assert(yieldValue > 5.5, `Expected high yield >5.5%, got ${yieldValue}%`);
  
  // May still be negative due to expenses
  const cashflowText = calc.$('out_cashflow').innerText;
  assert(!cashflowText.includes('NaN'), 'Should calculate cashflow correctly');
});

test('Real-world: First home buyer with LMI', 'ui', async () => {
  const calc = getCalculator();
  
  // FHB: $600k property, 10% deposit
  calc.$('price').value = 600000;
  calc.$('deposit_percent').value = 10;
  calc.$('interest_rate').value = 6.2;
  calc.updateAll();
  await wait(200);
  
  const lmiChecked = calc.$('include_lmi').checked;
  assert(lmiChecked, 'LMI should be enabled for 10% deposit');
  
  const lmiText = calc.$('out_lmi').innerText;
  const lmi = parseInt(lmiText.replace(/[^0-9]/g, ''));
  assert(lmi > 10000, `Expected significant LMI, got $${lmi}`);
});

test('Real-world: Investor with depreciation benefits', 'ui', async () => {
  const calc = getCalculator();
  
  // New apartment: $550k, 2-year-old building
  calc.$('price').value = 550000;
  calc.$('rent_week').value = 500;
  calc.$('deposit_percent').value = 20;
  calc.$('include_depreciation').checked = true;
  calc.$('building_value').value = 400000;
  calc.$('building_age').value = 2;
  calc.$('plant_value').value = 50000;
  calc.$('taxBracket').value = 0.37;
  calc.updateAll();
  await wait(200);
  
  const depText = calc.$('out_depreciation').innerText;
  const dep = parseInt(depText.replace(/[^0-9]/g, ''));
  assert(dep > 8000, `Expected significant depreciation, got $${dep}`);
  
  const refundText = calc.$('out_tax_refund').innerText;
  const refund = parseInt(refundText.replace(/[^0-9]/g, ''));
  assert(refund > 0, `Expected tax refund with negative gearing, got $${refund}`);
});

// ============================================================================
// Helper Functions
// ============================================================================

function getCalculator() {
  const iframe = document.getElementById('calculator');
  const calc = iframe.contentWindow;
  return {
    window: calc,
    document: calc.document,
    $: (id) => calc.document.getElementById(id),
    updateAll: () => calc.updateAll(),
    updateBuyerCalcs: () => calc.updateBuyerCalcs(),
    updateCapitalAppreciation: () => calc.updateCapitalAppreciation()
  };
}

// Copy calculation functions from main calculator for testing
function calcNSWDuty(price) {
  const nswDutyTable = [
    {min: 0,      max: 16000,  base: 0,      ratePer100: 1.25},
    {min: 16000,  max: 35000,  base: 200,    ratePer100: 1.50},
    {min: 35000,  max: 93000,  base: 485,    ratePer100: 1.75},
    {min: 93000,  max: 351000, base: 1500,   ratePer100: 3.50},
    {min: 351000, max: 1168000, base:10530,  ratePer100: 4.50},
    {min: 1168000, max: Infinity, base:47295, ratePer100: 5.50}
  ];
  
  price = Number(price) || 0;
  for(const row of nswDutyTable){
    if(price >= row.min && price <= row.max){
      const excess = Math.max(0, price - row.min);
      const duty = row.base + (excess / 100) * row.ratePer100;
      return Math.round(duty);
    }
  }
  return 0;
}

function wait(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// ============================================================================
// Test Runner
// ============================================================================

async function runTests(filter = null) {
  totalTests = 0;
  passedTests = 0;
  failedTests = 0;
  
  const resultsDiv = document.getElementById('results');
  resultsDiv.innerHTML = '<div style="padding:20px;text-align:center;color:#666;">Loading calculator and running tests...</div>';
  
  // Wait for iframe to load
  const iframe = document.getElementById('calculator');
  if (!iframe.contentWindow.document.body) {
    await new Promise(resolve => {
      iframe.onload = resolve;
    });
    await wait(1000); // Extra wait for scripts to initialize
  }
  
  // Check for any console errors during load
  const calc = iframe.contentWindow;
  const loadErrors = [];
  const originalError = calc.console.error;
  calc.console.error = function(...args) {
    loadErrors.push(args.join(' '));
    originalError.apply(calc.console, args);
  };
  
  // Verify calculator loaded properly
  try {
    if (!calc.updateAll || typeof calc.updateAll !== 'function') {
      resultsDiv.innerHTML = '<div class="alert danger"><strong>‚ùå CRITICAL ERROR</strong><br>Calculator failed to load properly. updateAll function is missing or invalid.</div>';
      return;
    }
    
    // Try running updateAll to check for immediate errors
    calc.updateAll();
    await wait(300);
    
    if (loadErrors.length > 0) {
      resultsDiv.innerHTML = `<div class="alert danger"><strong>‚ùå CALCULATOR ERRORS DETECTED</strong><br>${loadErrors.join('<br>')}</div>`;
      return;
    }
  } catch(e) {
    resultsDiv.innerHTML = `<div class="alert danger"><strong>‚ùå CALCULATOR INITIALIZATION FAILED</strong><br>${e.message}<br><br>Stack: ${e.stack}</div>`;
    return;
  }
  
  resultsDiv.innerHTML = '';
  
  // Group tests by category
  const categories = {};
  tests.forEach(t => {
    if (!filter || t.category === filter) {
      if (!categories[t.category]) {
        categories[t.category] = [];
      }
      categories[t.category].push(t);
    }
  });
  
  // Run tests by category
  for (const [category, categoryTests] of Object.entries(categories)) {
    const suiteDiv = document.createElement('div');
    suiteDiv.className = 'test-suite';
    suiteDiv.innerHTML = `<h2>${category.toUpperCase()} Tests (${categoryTests.length})</h2>`;
    
    for (const test of categoryTests) {
      totalTests++;
      const testDiv = document.createElement('div');
      testDiv.className = 'test-case';
      
      try {
        await test.fn();
        passedTests++;
        testDiv.classList.add('pass');
        testDiv.innerHTML = `
          <div class="test-name">${test.name}</div>
          <div class="test-result"></div>
        `;
      } catch (error) {
        failedTests++;
        testDiv.classList.add('fail');
        testDiv.innerHTML = `
          <div>
            <div class="test-name">${test.name}</div>
            <div class="test-details">${error.message}${error.stack ? '<br><small>' + error.stack.split('\\n').slice(0,3).join('<br>') + '</small>' : ''}</div>
          </div>
          <div class="test-result"></div>
        `;
      }
      
      suiteDiv.appendChild(testDiv);
    }
    
    resultsDiv.appendChild(suiteDiv);
  }
  
  // Show summary
  const summaryDiv = document.getElementById('summary');
  const allPassed = failedTests === 0;
  summaryDiv.className = allPassed ? 'summary' : 'summary fail';
  summaryDiv.innerHTML = `
    <strong>Test Results:</strong> ${passedTests} / ${totalTests} passed
    ${failedTests > 0 ? `<br><strong>‚ö†Ô∏è ${failedTests} tests failed - Calculator has issues!</strong>` : '<br><strong>‚ú® All tests passed!</strong>'}
  `;
}

async function runAllTests() {
  await runTests();
}

async function runCalculationTests() {
  await runTests('calculation');
}

async function runUITests() {
  await runTests('ui');
}

// Auto-run on load
window.addEventListener('load', () => {
  setTimeout(runAllTests, 1500);
});
</script>

</body>
</html>
